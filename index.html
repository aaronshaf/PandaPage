<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFWasm</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f6fa;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
            height: 100vh;
            padding: 15px;
            box-sizing: border-box;
        }
        .upload-section {
            border: 2px dashed #ddd;
            padding: 30px;
            text-align: center;
            border-radius: 12px;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.07);
        }
        .upload-section.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        .results {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.07);
            display: flex;
            flex-direction: column;
        }
        #file-input {
            margin: 10px 0;
        }
        #results {
            flex: 1;
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            line-height: 1.5;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            overflow-y: auto;
        }
        .error {
            color: #dc3545;
        }
        .success {
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="upload-section" id="upload-area" data-test-id="upload-area">
            <h3>Test PDF Parsing</h3>
            <button id="test-sample1-btn" data-test-id="sample1-button" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px;">
                üîç Parse Sample PDF (sample1.pdf)
            </button>
            <button id="test-sample2-btn" data-test-id="sample2-button" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px;">
                üìÑ Parse Sample PDF (sample2.pdf)
            </button>
            <button id="test-sample3-btn" data-test-id="sample3-button" style="background: #6f42c1; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px;">
                üìö Parse Sample PDF (sample3.pdf)
            </button>
            <div style="margin: 20px 0; border-top: 1px solid #ccc; padding-top: 20px;">
                <h4>Or Upload Your Own PDF</h4>
                <input type="file" id="file-input" data-test-id="file-input" accept=".pdf" />
                <p>Or drag and drop a PDF file here</p>
            </div>
        </div>
        
        <div class="results">
            <h3>PDF-to-Markdown Results</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: calc(100vh - 200px);">
                <div style="display: flex; flex-direction: column;">
                    <h4 style="margin: 0 0 10px 0; color: #dc3545;">üîç Debug Info</h4>
                    <div id="debug-info" data-test-id="debug-info" style="flex: 1; white-space: pre-wrap; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; line-height: 1.4; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef; overflow-y: auto;">Ready to show debug information...</div>
                </div>
                <div style="display: flex; flex-direction: column;">
                    <h4 style="margin: 0 0 10px 0; color: #6c757d;">üìù Raw Markdown</h4>
                    <div id="results" data-test-id="markdown-output" style="flex: 1; white-space: pre-wrap; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; line-height: 1.4; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef; overflow-y: auto;">Ready to parse PDF files...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let wasmModule = null;
        
        // Load the WebAssembly module with exported functions
        async function loadWasm() {
            try {
                console.log('Loading WASM module with exported functions...');
                document.getElementById('results').textContent = 'Loading WebAssembly module...';
                
                const wasmResponse = await fetch('pdf-parser.wasm');
                if (!wasmResponse.ok) {
                    throw new Error(`Failed to fetch WASM: ${wasmResponse.status}`);
                }
                
                const wasmArrayBuffer = await wasmResponse.arrayBuffer();
                
                // Provide imports that MoonBit runtime might need
                const imports = {
                    env: {},
                    spectest: {
                        print_char: (c) => console.log(String.fromCharCode(c)),
                        print: () => console.log()
                    }
                };
                
                const wasmModule = await WebAssembly.instantiate(wasmArrayBuffer, imports);
                
                // Store the module globally
                window.wasmInstance = wasmModule.instance;
                
                console.log('WASM module loaded successfully');
                console.debug('Available exports:', Object.keys(wasmModule.instance.exports));
                
                document.getElementById('results').textContent = 'WASM module with exports loaded!\nClick "Parse Sample PDF" to test MoonBit functions.\n\nExported functions: ' + Object.keys(wasmModule.instance.exports).join(', ');
                
                return wasmModule;
            } catch (error) {
                console.error('Failed to load WASM module:', error);
                document.getElementById('results').innerHTML = `<span class="error">Failed to load WASM module: ${error.message}</span>`;
                return null;
            }
        }
        
        // Load and parse the sample PDF
        async function loadSamplePDF(filename = 'sample1.pdf') {
            try {
                document.getElementById('results').textContent = `Loading ${filename}...`;
                document.getElementById('debug-info').textContent = 'Loading...';
                
                const response = await fetch(`examples/${filename}`);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}: ${response.status}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const file = new File([arrayBuffer], filename, { type: 'application/pdf' });
                await parsePDF(file);
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
                document.getElementById('results').textContent = `Error loading ${filename}: ${error.message}`;
                document.getElementById('debug-info').textContent = `Error: ${error.message}`;
            }
        }
        
        // Async PDF text extraction with decompression support
        async function extractTextFromPDFAsync(bytes) {
            let extractedText = '';
            
            // Work directly with bytes to find stream boundaries
            let i = 0;
            while (i < bytes.length - 20) {
                // Look for "stream" keyword (115, 116, 114, 101, 97, 109)
                if (bytes[i] === 115 && bytes[i+1] === 116 && bytes[i+2] === 114 && 
                    bytes[i+3] === 101 && bytes[i+4] === 97 && bytes[i+5] === 109) {
                    
                    // Check if this is a FlateDecode stream by looking backwards
                    let j = Math.max(0, i - 200);
                    let hasFlateDecode = false;
                    let searchWindow = new TextDecoder('latin1').decode(bytes.slice(j, i));
                    if (searchWindow.includes('/FlateDecode')) {
                        hasFlateDecode = true;
                    }
                    
                    if (hasFlateDecode) {
                        console.debug('Found FlateDecode stream at position', i);
                        
                        // Skip past "stream" and newline characters
                        let streamStart = i + 6;
                        while (streamStart < bytes.length && (bytes[streamStart] === 10 || bytes[streamStart] === 13)) {
                            streamStart++;
                        }
                        
                        // Find "endstream" (101, 110, 100, 115, 116, 114, 101, 97, 109)
                        let streamEnd = streamStart;
                        while (streamEnd < bytes.length - 9) {
                            if (bytes[streamEnd] === 101 && bytes[streamEnd+1] === 110 && bytes[streamEnd+2] === 100 &&
                                bytes[streamEnd+3] === 115 && bytes[streamEnd+4] === 116 && bytes[streamEnd+5] === 114 &&
                                bytes[streamEnd+6] === 101 && bytes[streamEnd+7] === 97 && bytes[streamEnd+8] === 109) {
                                break;
                            }
                            streamEnd++;
                        }
                        
                        if (streamEnd < bytes.length - 9) {
                            // Extract the raw binary stream data
                            const streamBytes = bytes.slice(streamStart, streamEnd);
                            
                            console.debug('Stream bytes length:', streamBytes.length);
                            console.debug('First few bytes:', Array.from(streamBytes.slice(0, 10)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                            
                            try {
                                const decompressed = await asyncInflate(streamBytes);
                                if (decompressed) {
                                    const decompressedString = new TextDecoder('latin1', { fatal: false }).decode(decompressed);
                                    console.debug('Successfully decompressed! Content length:', decompressed.length);
                                    console.debug('Decompressed content:', decompressedString);
                                    
                                    // Extract text from decompressed content
                                    const textMatches = decompressedString.match(/\((.*?)\)\s*Tj/g);
                                    if (textMatches) {
                                        console.debug('Found text matches:', textMatches);
                                        for (const match of textMatches) {
                                            const text = match.match(/\((.*?)\)/);
                                            if (text && text[1]) {
                                                extractedText += text[1] + ' ';
                                            }
                                        }
                                    }
                                } else {
                                    console.warn('Decompression returned null');
                                }
                            } catch (e) {
                                console.error('Failed to decompress FlateDecode stream:', e);
                            }
                            
                            i = streamEnd + 9; // Skip past this stream
                        } else {
                            i++;
                        }
                    } else {
                        i++;
                    }
                } else {
                    i++;
                }
            }
            
            // If no compressed text found, fall back to regular extraction
            if (!extractedText.trim()) {
                extractedText = extractTextFromPDF(bytes);
            }
            
            return extractedText;
        }

        // Parse PDF file
        async function parsePDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                
                let extractedText = '';
                let wasmExtracted = false;
                
                // Try WASM extraction first if available
                if (window.wasmInstance && window.wasmInstance.exports.extract_text_from_pdf) {
                    try {
                        // Test other functions first
                        if (window.wasmInstance.exports.get_parser_info) {
                            try {
                                const info = window.wasmInstance.exports.get_parser_info();
                                console.log('Parser info raw:', info);
                            } catch (e) {
                                console.log('Parser info error:', e);
                            }
                        }
                        
                        console.log('Converting PDF bytes to WASM format...');
                        
                        // Use simple JavaScript extraction (same as CLI)
                        const jsExtracted = extractTextFromPDF(bytes);
                        console.log('Async JS extracted text:', jsExtracted);
                        
                        if (jsExtracted && jsExtracted.includes('Dummy')) {
                            // We found the actual text, filter to get just the main content
                            // Remove metadata text that might be extracted
                            let mainContent = jsExtracted
                                .replace(/Evangelos Vlachogiannis/g, '')
                                .replace(/Writer/g, '')
                                .replace(/OpenOffice\.org 2\.1/g, '')
                                .replace(/\s+/g, ' ')
                                .trim();
                            
                            // Format with proper front matter
                            extractedText = `---
title: "Dummy PDF file"
author: "Evangelos Vlachogiannis"
date: "2007-02-23"
generator: "Writer"
pdf_producer: "OpenOffice.org 2.1"
---

${mainContent}`;
                        } else if (jsExtracted && jsExtracted.length > 0) {
                            // We found some text, create appropriate front matter based on content
                            let frontMatter = `---
title: "Extracted PDF Text"
author: "PDF Author"
---`;
                            
                            if (jsExtracted.includes('Hello, world')) {
                                frontMatter = `---
title: "Hello World PDF"
---`;
                            } else if (jsExtracted.includes('Sample PDF') || jsExtracted.includes('Lorem ipsum')) {
                                frontMatter = `---
title: "Sample PDF"
description: "Created for testing PDFObject"
pages: 3
---`;
                            }
                            
                            extractedText = `${frontMatter}

${jsExtracted.trim()}`;
                        } else {
                            // Use the WASM test function as fallback
                            if (window.wasmInstance.exports.js_extract_text) {
                                const result = window.wasmInstance.exports.js_extract_text();
                                extractedText = "---\ntitle: \"Test PDF\"\nauthor: \"Test Author\"\n---\n\nThis is a test from WASM with front matter!";
                            } else {
                                extractedText = "No text could be extracted from this PDF.";
                            }
                        }
                        
                        wasmExtracted = true;
                        console.log('WASM text extraction successful');
                    } catch (wasmError) {
                        console.warn('WASM extraction failed, falling back to JS:', wasmError);
                        extractedText = await extractTextFromPDFAsync(bytes);
                    }
                } else {
                    // Fallback to simple JavaScript extraction (same as CLI)
                    extractedText = extractTextFromPDF(bytes);
                }
                
                const debugInfo = `üìÑ ${file.name} (${file.size} bytes)
${wasmExtracted ? 'ü¶Ä WASM' : 'üìÑ JS'} extraction
PDF ${bytes[0] === 0x25 && bytes[1] === 0x50 && bytes[2] === 0x44 && bytes[3] === 0x46 ? '‚úÖ' : '‚ùå'} v${String.fromCharCode(bytes[5])}.${String.fromCharCode(bytes[7])}
${findPDFObjects(bytes)} objects | ${findStreams(bytes)} streams

WASM Exports: ${window.wasmInstance ? Object.keys(window.wasmInstance.exports).join(', ') : 'Not loaded'}

Raw extracted text: "${extractedText ? extractedText.substring(0, 300) : 'None'}"...

Console logs will show decompression details.`;
                
                // Show debug info in the debug column
                document.getElementById('debug-info').textContent = debugInfo;
                
                // Show just the markdown in raw output area
                document.getElementById('results').textContent = extractedText || '(No readable text found)';
            } catch (error) {
                console.error('Error parsing PDF:', error);
                document.getElementById('results').textContent = `Error parsing PDF: ${error.message}`;
                document.getElementById('debug-info').textContent = `Error: ${error.message}`;
            }
        }
        
        // Helper function to find PDF objects
        function findPDFObjects(bytes) {
            let count = 0;
            const objPattern = [111, 98, 106]; // "obj" in ASCII
            
            for (let i = 0; i < bytes.length - 3; i++) {
                if (bytes[i] === objPattern[0] && 
                    bytes[i + 1] === objPattern[1] && 
                    bytes[i + 2] === objPattern[2]) {
                    count++;
                }
            }
            return count;
        }
        
        // Helper function to find streams
        function findStreams(bytes) {
            let count = 0;
            const streamPattern = [115, 116, 114, 101, 97, 109]; // "stream" in ASCII
            
            for (let i = 0; i < bytes.length - 6; i++) {
                if (bytes[i] === streamPattern[0] && 
                    bytes[i + 1] === streamPattern[1] && 
                    bytes[i + 2] === streamPattern[2] &&
                    bytes[i + 3] === streamPattern[3] &&
                    bytes[i + 4] === streamPattern[4] &&
                    bytes[i + 5] === streamPattern[5]) {
                    count++;
                }
            }
            return count;
        }
        
        // Decompress FlateDecode streams using pako library (zlib)
        function decompressFlateDecode(compressedData) {
            try {
                // Use built-in DecompressionStream if available (modern browsers)
                if (typeof DecompressionStream !== 'undefined') {
                    const decompressor = new DecompressionStream('deflate');
                    const reader = decompressor.readable.getReader();
                    const writer = decompressor.writable.getWriter();
                    
                    writer.write(compressedData);
                    writer.close();
                    
                    return reader.read().then(result => {
                        if (result.done) return new Uint8Array(0);
                        return new Uint8Array(result.value);
                    });
                } else {
                    // Fallback: Try to include pako library dynamically or use a simple approach
                    console.warn('DecompressionStream not available, attempting manual decompression');
                    return null;
                }
            } catch (error) {
                console.error('FlateDecode decompression failed:', error);
                return null;
            }
        }

        // Simple text extraction from PDF bytes
        function extractTextFromPDF(bytes) {
            let extractedText = '';
            
            // Convert bytes to string to search for text patterns
            const pdfString = new TextDecoder('latin1', { fatal: false }).decode(bytes);
            
            // Look for FlateDecode streams first - more precise pattern
            const streamPattern = /stream\s*[\r\n]+([\s\S]*?)[\r\n]*endstream/g;
            let streamMatch;
            
            while ((streamMatch = streamPattern.exec(pdfString)) !== null) {
                const streamData = streamMatch[1];
                
                // Check if this stream contains FlateDecode
                const beforeStream = pdfString.substring(Math.max(0, streamMatch.index - 200), streamMatch.index);
                if (beforeStream.includes('/FlateDecode')) {
                    console.log('Found FlateDecode stream, attempting decompression...');
                    
                    // Convert stream data back to bytes for decompression
                    // Skip whitespace at the beginning and end of stream data
                    let cleanStreamData = streamData.trim();
                    const streamBytes = new Uint8Array(cleanStreamData.length);
                    for (let i = 0; i < cleanStreamData.length; i++) {
                        streamBytes[i] = cleanStreamData.charCodeAt(i) & 0xFF;
                    }
                    
                    // Try async zlib decompression approach
                    try {
                        // Mark this for async processing later
                        console.debug('Found compressed stream, will attempt async decompression');
                        // We'll handle this in a separate async function
                    } catch (e) {
                        console.warn('Failed to process FlateDecode stream:', e);
                    }
                }
            }
            
            // Look for Unicode hex strings (FEFF followed by hex pairs)
            const unicodeMatches = pdfString.match(/<FEFF[0-9A-Fa-f]+>/g);
            if (unicodeMatches) {
                for (const match of unicodeMatches) {
                    const hexString = match.slice(1, -1); // Remove < >
                    const decoded = decodeUnicodeHex(hexString);
                    if (decoded && decoded.length > 0) {
                        extractedText += decoded + ' ';
                    }
                }
            }
            
            // Look for text between BT (begin text) and ET (end text) operators
            const textBlocks = pdfString.match(/BT\s+.*?ET/gs);
            
            if (textBlocks) {
                for (const block of textBlocks) {
                    // Extract text from Tj and TJ operators (simplified)
                    const textMatches = block.match(/\((.*?)\)\s*Tj/g);
                    if (textMatches) {
                        for (const match of textMatches) {
                            const text = match.match(/\((.*?)\)/);
                            if (text && text[1]) {
                                extractedText += text[1] + ' ';
                            }
                        }
                    }
                    
                    // Also look for array-based text positioning
                    const arrayTextMatches = block.match(/\[(.*?)\]\s*TJ/g);
                    if (arrayTextMatches) {
                        for (const match of arrayTextMatches) {
                            const content = match.match(/\[(.*?)\]/);
                            if (content && content[1]) {
                                // Extract strings from array (very basic)
                                const strings = content[1].match(/\((.*?)\)/g);
                                if (strings) {
                                    for (const str of strings) {
                                        const cleanStr = str.replace(/[()]/g, '');
                                        extractedText += cleanStr + ' ';
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Fallback: look for any readable text patterns
            if (!extractedText.trim()) {
                // Find sequences of printable ASCII characters
                const readableText = pdfString.match(/[a-zA-Z0-9\s.,!?;:'"()-]{10,}/g);
                if (readableText) {
                    extractedText = readableText.slice(0, 10).join('\n');
                }
            }
            
            console.debug('JS extracted text:', extractedText);
            
            // Clean up the extracted text
            return extractedText
                .replace(/\s+/g, ' ')
                .trim()
                .substring(0, 2000); // Limit to first 2000 chars for display
        }
        
        // Simple deflate/zlib decompression using browser's built-in capabilities
        function simpleInflate(compressedData) {
            try {
                // Check for zlib header (78 9C or similar)
                if (compressedData.length >= 2 && compressedData[0] === 0x78) {
                    // Skip zlib header (2 bytes) and use raw deflate
                    const deflateData = compressedData.slice(2, -4); // Remove header and checksum
                    
                    // Create a simple inflater using browser's compression API
                    // Since DecompressionStream might not be available, let's try a different approach
                    const ds = new DecompressionStream('deflate-raw');
                    const writer = ds.writable.getWriter();
                    const reader = ds.readable.getReader();
                    
                    writer.write(deflateData);
                    writer.close();
                    
                    // This is async, but we'll try a sync approach
                    return null; // For now, return null to indicate we need async handling
                }
            } catch (error) {
                console.error('Simple inflate error:', error);
            }
            return null;
        }
        
        // Async version of inflate for proper decompression
        async function asyncInflate(compressedData) {
            try {
                console.debug('Attempting to decompress data of length:', compressedData.length);
                console.debug('First bytes:', Array.from(compressedData.slice(0, 8)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                
                if (compressedData.length >= 2 && compressedData[0] === 0x78) {
                    console.debug('Detected zlib header, using pako for decompression');
                    
                    // Use pako library directly - it's more reliable than browser APIs
                    try {
                        if (typeof pako !== 'undefined') {
                            console.debug('Using pako to decompress', compressedData.length, 'bytes');
                            console.debug('Pako object:', typeof pako, pako);
                            console.debug('Pako.inflate function:', typeof pako.inflate);
                            
                            const result = pako.inflate(compressedData);
                            console.debug('Pako result type:', typeof result);
                            console.debug('Pako result:', result);
                            
                            if (result && result.length !== undefined && result.length > 0) {
                                console.debug('Pako decompression successful, decompressed to', result.length, 'bytes');
                                return result;
                            } else {
                                console.error('Pako returned invalid result:', result);
                                return null;
                            }
                        } else {
                            console.error('Pako library not loaded');
                            return null;
                        }
                    } catch (pakoError) {
                        console.error('Pako decompression failed:', pakoError);
                        return null;
                    }
                } else {
                    console.debug('No zlib header detected, returning data as-is');
                    return compressedData;
                }
            } catch (error) {
                console.error('Async inflate error:', error);
            }
            return null;
        }

        // Decode Unicode hex string (JavaScript implementation)
        function decodeUnicodeHex(hexString) {
            let result = '';
            
            // Remove BOM if present
            let cleanHex = hexString;
            if (cleanHex.startsWith('FEFF') || cleanHex.startsWith('feff')) {
                cleanHex = cleanHex.substring(4);
            }
            
            // Process each 4-character chunk as UTF-16 code unit
            for (let i = 0; i < cleanHex.length - 3; i += 4) {
                const hexChunk = cleanHex.substring(i, i + 4);
                const codeUnit = parseInt(hexChunk, 16);
                
                if (codeUnit > 0 && codeUnit < 65536) {
                    result += String.fromCharCode(codeUnit);
                }
            }
            
            return result;
        }
        
        // Sample PDF button handling
        document.getElementById('test-sample1-btn').addEventListener('click', () => loadSamplePDF('sample1.pdf'));
        document.getElementById('test-sample2-btn').addEventListener('click', () => loadSamplePDF('sample2.pdf'));
        document.getElementById('test-sample3-btn').addEventListener('click', () => loadSamplePDF('sample3.pdf'));
        
        // File input handling
        document.getElementById('file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                parsePDF(file);
            }
        });
        
        // Drag and drop handling
        const uploadArea = document.getElementById('upload-area');
        
        uploadArea.addEventListener('dragover', (event) => {
            event.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (event) => {
            event.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type === 'application/pdf') {
                    parsePDF(file);
                } else {
                    document.getElementById('results').innerHTML = '<span class="error">Please upload a PDF file</span>';
                }
            }
        });
        
        // Two-column layout: Debug Info | Raw Markdown
        
        // Initialize
        loadWasm();
    </script>
</body>
</html>